# Story TD-001: Replace Hard Sleeps in Tests with Deterministic Polling

Status: ready-for-dev

<!-- Generated by create-story workflow in YOLO mode by Scrum Master Bob -->

## Story

As a developer,
I want all hard sleeps in tests replaced with deterministic polling patterns,
So that tests complete faster, are more reliable across environments, and won't fail due to timing issues on slow CI systems.

## Acceptance Criteria

1. **Given** I run the test suite on a fast development machine **When** tests complete **Then** they should finish significantly faster than before (target: 20-30% reduction in test time) **And** no tests should unnecessarily wait the full sleep duration when conditions are met early

2. **Given** I run the test suite on a slow CI system **When** tests execute under load **Then** all tests should pass reliably without timing-based failures **And** polling should adaptively wait for actual conditions rather than fixed durations

3. **Given** I examine test files after migration **When** I search for `sleep(` patterns **Then** I should only find sleeps inside the polling helpers themselves **And** all test code should use `poll_until`, `poll_with_diagnostics`, or `wait_for_channel_message` instead

4. **Given** a test previously used `sleep(Duration::from_millis(600))` to wait for a condition **When** migrated to polling **Then** the test should use `poll_until(Duration::from_secs(2), || async { /* condition */ })` **And** include a meaningful timeout that's longer than the original sleep

5. **Given** I run `cargo test` after the migration **When** all tests complete **Then** the test suite should pass with no regressions **And** test output should remain clear and actionable

## Tasks / Subtasks

- [ ] Evaluate performance test sleeps - determine simulation vs synchronization (AC: #1, #3, #4)
  - [ ] Review `test_message_delivery_latency_online` line 163 - simulated network ACK delay
  - [ ] Review `test_message_latency_histogram` line 395 - simulated ACK delay
  - [ ] Review `test_concurrent_connections` line 330 - simulated message send delay
  - [ ] Review `test_websocket_handshake_latency` line 276 - inter-test delay
  - [ ] Document simulation sleeps clearly OR replace with actual backend if possible
  
- [ ] Migrate e2e test sleeps to polling (AC: #1, #2, #3, #4)
  - [ ] Replace login retry sleep at line 209 with `poll_until` for login success
  - [ ] Verify exponential backoff logic replaced by polling timeout strategy
  
- [ ] Enhance message delivery test polling (AC: #1, #2, #3, #4)
  - [ ] Review existing partial polling migration at line 94-106 (already uses `poll_until`)
  - [ ] Assess line 151 sleep - determine if needed or can be replaced with polling
  
- [ ] Audit production code sleeps for validity (AC: #3)
  - [ ] Review `src/frontend/screens/user_search_screen.rs:65` - likely intentional debounce
  - [ ] Review `src/frontend/screens/chat_screen.rs:783` - determine if test artifact or intentional
  - [ ] Document any production sleeps that are intentional business logic
  
- [ ] Verify test suite improvements (AC: #5)
  - [ ] Run full test suite before migration (baseline timing)
  - [ ] Run full test suite after migration (verify improvements)
  - [ ] Measure and document test execution time reduction
  - [ ] Ensure 100% pass rate with no regressions

## Dev Notes

### Background Context

The codebase has an excellent polling infrastructure already in place (`tests/helpers/polling.rs`), but several tests still use hard-coded sleeps. This technical debt causes:
- **Flaky tests** on slow CI systems (sleep might be too short)
- **Slow tests** on fast machines (sleep might be too long)  
- **Non-deterministic behavior** (waits full duration even if condition met early)

### Existing Polling Infrastructure

**Location:** `tests/helpers/polling.rs` (195 lines, well-tested)

Three robust helpers available:

1. **`poll_until(duration, condition)`** - Core polling pattern
   - Checks condition immediately before first sleep
   - Polls every 50ms until condition true or timeout
   - Returns `Ok(())` on success, `Err(Elapsed)` on timeout

2. **`poll_with_diagnostics(duration, name, condition)`** - Enhanced polling with timing logs
   - Same as `poll_until` but logs attempts and timing
   - Useful for debugging flaky tests
   - Example output: `✓ [user_online_status] Success after 7 attempts (342ms)`

3. **`wait_for_channel_message(rx, duration)`** - Specialized channel helper
   - Uses `tokio::timeout` for channel receives
   - Cleaner than manual polling for channel waits

### Migration Patterns

#### Pattern 1: Database State Polling

**Before (Hard Sleep):**
```rust
// Wait for message to be queued
tokio::time::sleep(Duration::from_millis(600)).await;
let msg = db::find_message_by_id(&pool, &message_id).await.unwrap();
assert_eq!(msg.status, "queued");
```

**After (Deterministic Polling):**
```rust
use crate::helpers::polling::poll_until;

poll_until(Duration::from_secs(2), || async {
    let msg = db::find_message_by_id(&pool, &message_id).await.ok().flatten();
    msg.map(|m| m.status == "queued").unwrap_or(false)
})
.await
.expect("message never reached queued status");
```

**Key improvements:**
- Returns immediately when condition is met (not after full 600ms)
- Longer timeout (2s) handles slow CI systems safely
- Clear error message on timeout

#### Pattern 2: Login Retry with Backoff

**Before (Manual Backoff Sleep):**
```rust
// tests/integration/e2e_test.rs:209
tokio::time::sleep(Duration::from_millis(50 * login_attempt as u64)).await;
```

**After (Polling with Single Timeout):**
```rust
use crate::helpers::polling::poll_until;

poll_until(Duration::from_secs(5), || async {
    // Attempt login and check if successful
    match login_service.attempt_login(&username, &password).await {
        Ok(session) => {
            // Store session for test
            *test_session.lock().await = Some(session);
            true // Login succeeded
        }
        Err(_) => false // Keep polling
    }
})
.await
.expect("login never succeeded within timeout");
```

**Key improvements:**
- Eliminates exponential backoff sleep entirely
- Polls as fast as possible (50ms intervals)
- Single clear timeout replaces complex backoff logic

#### Pattern 3: Message Persistence Ordering

**Before (Sequential Sleeps):**
```rust
// tests/integration/message_delivery_test.rs:151
for i in 0..3 {
    service.send_message(/*...*/).await.unwrap();
    // Wait for persistence before sending next
    tokio::time::sleep(tokio::time::Duration::from_millis(10)).await;
}
```

**After (Deterministic Polling):**
```rust
use crate::helpers::polling::poll_until;

for i in 0..3 {
    let msg = service.send_message(/*...*/).await.unwrap();
    
    // Wait for message to be persisted before sending next
    let msg_id = msg.id.clone();
    let pool_clone = pool.clone();
    poll_until(Duration::from_millis(500), || {
        let id = msg_id.clone();
        let p = pool_clone.clone();
        async move {
            db::queries::find_message_by_id(&p, &id)
                .await
                .ok()
                .flatten()
                .is_some()
        }
    })
    .await
    .expect(&format!("message {} never persisted", i));
}
```

**Key improvements:**
- Guarantees ordering by actually checking persistence
- Completes immediately when persisted (not fixed 10ms)
- Better error message identifies which message failed

### Performance Test Sleep Evaluation

**Location:** `tests/integration/performance_test.rs`

**Critical Decision:** The performance tests contain sleeps that are **intentional simulations**, not synchronization waits. These fall into two categories:

#### Category A: Keep (Simulation Sleeps)

These simulate network/system delays for realistic performance testing:

```rust
// Line 115: Simulated network delay
sleep(Duration::from_millis(50)).await; // WebSocket handshake simulation

// Line 126: Simulated serialization + network
sleep(Duration::from_millis(10)).await; // Message send simulation

// Line 163: Simulated ACK delay
sleep(Duration::from_millis(50)).await; // Delivery confirmation

// Line 395: Simulated ACK
sleep(Duration::from_millis(10)).await;
```

**Recommendation:** Keep these sleeps but add clear comments:
```rust
// INTENTIONAL SIMULATION: Network ACK delay (not a test synchronization sleep)
sleep(Duration::from_millis(50)).await;
```

#### Category B: Replace (Inter-Test Delays)

These are actual synchronization/spacing sleeps:

```rust
// Line 276: Small delay between handshakes
sleep(Duration::from_millis(10)).await;

// Line 330: Delay between concurrent message sends
sleep(Duration::from_millis(100)).await;
```

**Recommendation:** These can potentially be removed or replaced with actual synchronization if needed.

### Existing Good Example

`tests/integration/message_delivery_test.rs` (lines 94-106) already demonstrates excellent polling usage:

```rust
// GIVEN: Message is queued (deterministically wait for DB state)
let message_id = message.id.clone();
let pool_for_poll = pool.clone();
poll_until(Duration::from_secs(2), || {
    let id = message_id.clone();
    let p = pool_for_poll.clone();
    async move {
        if let Ok(Some(msg)) = db::queries::find_message_by_id(&p, &id).await {
            msg.status == "queued"
        } else {
            false
        }
    }
})
.await
.expect("message never queued");
```

This is the pattern to follow for all other migrations.

### Files Requiring Action

#### Priority 1: Clear Migration Targets
1. **`tests/integration/e2e_test.rs:209`** - Login retry sleep → Replace with `poll_until`
2. **`tests/integration/e2e_test.rs:151`** - Message ordering sleep → Replace with `poll_until` 
3. **`tests/integration/message_delivery_test.rs:151`** - Already has some polling, verify completeness

#### Priority 2: Evaluation Required
4. **`tests/integration/performance_test.rs`** (lines 115, 126, 163, 276, 330, 395)
   - Distinguish simulation sleeps (keep + document) from sync sleeps (replace)

#### Priority 3: Production Code Audit
5. **`src/frontend/screens/user_search_screen.rs:65`** - Likely intentional debounce, verify
6. **`src/frontend/screens/chat_screen.rs:783`** - Verify if test artifact or intentional logic

### Project Structure Notes

```
tests/
├── helpers/
│   ├── mod.rs (exports polling module)
│   └── polling.rs (✓ Complete infrastructure with 3 helpers + comprehensive tests)
├── integration/
│   ├── e2e_test.rs (TARGET: lines 151, 209)
│   ├── message_delivery_test.rs (REVIEW: line 151, verify lines 94-106 completeness)
│   └── performance_test.rs (EVALUATE:determine simulation vs sync sleeps)
└── fixtures/
    └── mod.rs (test setup helpers)
```

**Import pattern:**
```rust
use crate::helpers::polling::{poll_until, poll_with_diagnostics, wait_for_channel_message};
```

### Architecture Compliance

From `docs/architecture.md`:

- **Pattern 9: Testing Organization** - All test helpers centralized in `tests/helpers/`
- **NFR6-2c**: Target ≥70% code coverage maintained after refactor
- **NFR6-2e**: UI components have visual regression tests (not affected by this story)
- **Testing Strategy**: Emphasizes deterministic patterns over time-based waits

### Testing Requirements

- **Before Migration Baseline:**
  - Run `cargo test` and record total execution time
  - Verify 100% pass rate before changes
  
- **After Migration Verification:**
  - Run `cargo test` - must maintain 100% pass rate
  - Measure total execution time - should be 20-30% faster
  - Run tests on both fast development machine and simulate slow CI
  
- **regression detection:**
  - Any test that was passing before must pass after
  - Test output clarity must be maintained or improved
  - No new flaky behavior introduced

### Expected Outcomes

- **Test Speed:** 20-30% reduction in total test execution time
- **Reliability:** Zero timing-based failures on slow CI systems
- **Maintainability:** Clear pattern for future test development
- **Debuggability:** Better error messages with poll diagnostics

### References

- [Source: docs/epics.md] - Technical Debt epic definition
- [Source: tests/helpers/polling.rs] - Complete polling infrastructure with tests
- [Source: docs/architecture.md#Pattern-9] - Testing patterns and standards
- [Source: tests/integration/message_delivery_test.rs:94-106] - Excellent existing example
- [Source: NFR6-2c in architecture.md] - Code coverage requirements
- [Source: grep results] - Identified 19+ sleep instances across codebase

## Dev Agent Record

### Agent Model Used

{{agent_model_name_version}}

### Debug Log References

### Completion Notes List

### File List
