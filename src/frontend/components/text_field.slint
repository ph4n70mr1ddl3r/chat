import { Tokens } from "../design/tokens.slint";
import { LineEdit } from "std-widgets.slint";

export component TextField {
    // Category 1: Data Props (Structural)
    in-out property <string> value <=> inner_line_edit.text;
    in property <string> placeholder: "";
    in property <string> error_message: "";
    in property <string> label: ""; // For accessibility

    // Category 2: Behavior Props (Callbacks)
    callback on_text_changed(string);
    callback on_return_pressed();
    callback on_focus();
    callback on_blur();

    // Category 3: Style & Context Props (Optional)
    in property <bool> is_disabled: false;
    in property <bool> has_error: false;
    in property <bool> reduce_motion: Tokens.prefers_reduced_motion;

    // Internal State
    private property <bool> has_focus: inner_line_edit.has-focus;
    forward-focus: inner_line_edit;
    VerticalLayout {
        spacing: Tokens.spacing_xs;
        container := Rectangle {
            height: 36px;
            background: is_disabled ? Tokens.neutral_light : (has_focus ? white : Tokens.neutral_light);
            border-width: has_focus || has_error ? 2px : 1px;
            border-color: has_error ? Tokens.error : (has_focus ? Tokens.fluent_blue : (is_disabled ? Tokens.neutral_medium : Tokens.neutral_medium));
            border-radius: 4px;

            // Focus ring (2px offset)
            if has_focus: Rectangle {
                x: -4px;
                y: -4px;
                width: parent.width + 8px;
                height: parent.height + 8px;
                border-width: 2px;
                border-color: Tokens.fluent_blue;
                border-radius: 6px;
                animate border-color { duration: reduce_motion ? 0ms : Tokens.duration_quick; }
            }
            inner_line_edit := LineEdit {
                x: Tokens.spacing_sm;
                width: parent.width - (Tokens.spacing_sm * 2);
                height: 100%;
                placeholder-text: placeholder;
                enabled: !is_disabled;
                font-size: Tokens.font_size_body;
                accessible-role: text-input;
                accessible-label: label != "" ? label : placeholder;
                edited(text) => {
                    on_text_changed(text);
                }
                accepted() => {
                    on_return_pressed();
                }
            }
        }

        if has_error && error_message != "": Text {
            text: error_message;
            color: Tokens.error;
            font-size: Tokens.font_size_caption;
            animate opacity { duration: Tokens.duration_quick; }
        }
    }
}
